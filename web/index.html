<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>写真台帳AI - Gemini</title>
  <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai",
        "pdf-lib": "https://esm.run/pdf-lib",
        "xlsx": "https://esm.run/xlsx",
        "@pdf-lib/fontkit": "https://esm.run/@pdf-lib/fontkit"
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; min-height: 100vh; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    header { background: #1a73e8; color: white; padding: 20px; margin-bottom: 20px; border-radius: 8px; }
    header h1 { font-size: 1.5rem; }
    header p { font-size: 0.9rem; opacity: 0.9; margin-top: 5px; }
    .settings { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .settings label { display: block; margin-bottom: 5px; font-weight: 500; }
    .settings input, .settings select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; margin-bottom: 10px; }
    .settings input[type="password"] { font-family: monospace; }
    .settings-row { display: flex; gap: 20px; }
    .settings-row > div { flex: 1; }
    .upload-area { background: white; border: 2px dashed #ddd; border-radius: 8px; padding: 40px; text-align: center; margin-bottom: 20px; cursor: pointer; transition: border-color 0.3s; }
    .upload-area:hover { border-color: #1a73e8; }
    .upload-area.dragover { border-color: #1a73e8; background: #e8f0fe; }
    .upload-area input { display: none; }
    .btn { background: #1a73e8; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px; }
    .btn:hover { background: #1557b0; }
    .btn:disabled { background: #ccc; cursor: not-allowed; }
    .btn-success { background: #34a853; }
    .btn-success:hover { background: #2d8a47; }
    .btn-secondary { background: #666; }
    .photos { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px; }
    .photo-card { background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .photo-card img { width: 100%; height: 150px; object-fit: cover; }
    .photo-card .info { padding: 10px; font-size: 12px; }
    .photo-card .info .filename { font-weight: 500; margin-bottom: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .photo-card .info .field { color: #666; margin-bottom: 2px; }
    .photo-card .info .field span { color: #333; }
    .photo-card.done { border-left: 4px solid #34a853; }
    .progress { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .progress-bar { height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; }
    .progress-bar .fill { height: 100%; background: #1a73e8; transition: width 0.3s; }
    .progress-text { margin-top: 10px; font-size: 14px; color: #666; }
    .actions { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
    .log { background: #263238; color: #aed581; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; margin-bottom: 20px; }
    .log .error { color: #ef5350; }
    .log .success { color: #66bb6a; }
    .log .info { color: #42a5f5; }
    .export-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
    .export-section h3 { margin-bottom: 15px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>写真台帳AI - Gemini</h1>
      <p>写真をアップロード → AI解析 → PDF/Excel写真台帳を出力</p>
    </header>

    <div class="settings">
      <div class="settings-row">
        <div>
          <label for="apiKey">Gemini API Key</label>
          <input type="password" id="apiKey" placeholder="AIzaSy..." />
        </div>
        <div>
          <label for="title">写真台帳タイトル</label>
          <input type="text" id="title" value="工事写真帳" />
        </div>
        <div>
          <label for="photosPerPage">1ページあたりの写真数</label>
          <select id="photosPerPage">
            <option value="2">2枚</option>
            <option value="3" selected>3枚</option>
          </select>
        </div>
      </div>
    </div>

    <div class="upload-area" id="uploadArea">
      <p>クリックまたはドラッグ&ドロップで写真を追加</p>
      <input type="file" id="fileInput" multiple accept="image/*" />
    </div>

    <div class="actions">
      <button class="btn" id="analyzeBtn" disabled>AI解析開始</button>
      <button class="btn btn-secondary" id="clearBtn">クリア</button>
    </div>

    <div class="progress" id="progressSection" style="display:none;">
      <div class="progress-bar"><div class="fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText">準備中...</div>
    </div>

    <div class="log" id="log"></div>

    <div class="photos" id="photosGrid"></div>

    <div class="export-section" id="exportSection" style="display:none;">
      <h3>写真台帳を出力</h3>
      <div class="actions">
        <button class="btn btn-success" id="exportPdfBtn">PDF出力</button>
        <button class="btn btn-success" id="exportExcelBtn">Excel出力</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { GoogleGenAI } from '@google/genai';
    import { PDFDocument, rgb } from 'pdf-lib';
    import fontkit from '@pdf-lib/fontkit';
    import * as XLSX from 'xlsx';

    // Noto Sans JP フォント (Google Fonts)
    const FONT_URL = 'https://fonts.gstatic.com/s/notosansjp/v52/-F6jfjtqLzI2JPCgQBnw7HFyzSD-AsregP8VFBEj75s.ttf';

    // Constants (same as Rust version)
    const A4_WIDTH = 595.28;
    const A4_HEIGHT = 841.89;
    const MARGIN = 40;
    const HEADER_HEIGHT = 40;
    const GAP = 5;
    const IMAGE_RATIO = 0.65;
    const INFO_RATIO = 0.35;
    const UNIFIED_FONT_SIZE = 12; // Rust版と統一

    // エイリアス変換（Rust版 matcher/alias.rs pavement_preset と同一）
    const PAVEMENT_ALIASES = {
      photoCategory: {
        '品質': '品質管理写真',
        '品質管理': '品質管理写真',
        '出来形': '出来形管理写真',
        '出来形管理': '出来形管理写真',
        '施工状況': '施工状況写真',
        '施工中': '施工状況写真',
        '安全': '安全管理写真',
        '安全管理': '安全管理写真',
        '材料': '使用材料写真',
        '使用材料': '使用材料写真'
      },
      workType: {
        '舗装': '舗装工',
        'As': '舗装工',
        'アスファルト': '舗装工'
      },
      variety: {
        '打換え': '舗装打換え工',
        '打換': '舗装打換え工',
        'オーバーレイ': '舗装オーバーレイ工'
      },
      detail: {
        '表層': '表層工',
        '基層': '基層工',
        '上層路盤': '上層路盤工',
        '下層路盤': '下層路盤工'
      }
    };

    function applyAlias(value, aliases) {
      if (!value) return value;
      if (aliases[value]) return aliases[value];
      // 部分一致（最長マッチ）
      let bestMatch = null;
      for (const [pattern, replacement] of Object.entries(aliases)) {
        if (value.includes(pattern)) {
          if (!bestMatch || pattern.length > bestMatch[0].length) {
            bestMatch = [pattern, replacement];
          }
        }
      }
      return bestMatch ? bestMatch[1] : value;
    }

    function applyAliases(result) {
      return {
        ...result,
        photoCategory: applyAlias(result.photoCategory, PAVEMENT_ALIASES.photoCategory),
        workType: applyAlias(result.workType, PAVEMENT_ALIASES.workType),
        variety: applyAlias(result.variety, PAVEMENT_ALIASES.variety),
        detail: applyAlias(result.detail, PAVEMENT_ALIASES.detail)
      };
    }

    // State
    let photos = [];
    let genAI = null;

    // Elements
    const apiKeyInput = document.getElementById('apiKey');
    const titleInput = document.getElementById('title');
    const photosPerPageSelect = document.getElementById('photosPerPage');
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const clearBtn = document.getElementById('clearBtn');
    const photosGrid = document.getElementById('photosGrid');
    const progressSection = document.getElementById('progressSection');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const logEl = document.getElementById('log');
    const exportSection = document.getElementById('exportSection');
    const exportPdfBtn = document.getElementById('exportPdfBtn');
    const exportExcelBtn = document.getElementById('exportExcelBtn');

    // Load saved API key
    const savedKey = localStorage.getItem('gemini_api_key');
    if (savedKey) apiKeyInput.value = savedKey;

    apiKeyInput.addEventListener('change', () => {
      localStorage.setItem('gemini_api_key', apiKeyInput.value);
      log('APIキーを保存しました', 'success');
    });

    function log(msg, type = '') {
      const line = document.createElement('div');
      line.className = type;
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // File handling
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    async function handleFiles(files) {
      for (const file of files) {
        if (!file.type.startsWith('image/')) continue;
        const base64 = await fileToBase64(file);
        photos.push({
          file,
          fileName: file.name,
          base64,
          mimeType: file.type,
          result: null
        });
      }
      renderPhotos();
      updateButtons();
      log(`${files.length}枚の写真を追加`, 'info');
    }

    function fileToBase64(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.readAsDataURL(file);
      });
    }

    function renderPhotos() {
      // Clear existing content
      photosGrid.textContent = '';
      const fragment = document.createDocumentFragment();

      photos.forEach((p, i) => {
        const photoCard = document.createElement('div');
        photoCard.className = 'photo-card' + (p.result ? ' done' : '');
        photoCard.id = `photo-${i}`;

        const img = document.createElement('img');
        // Validate mimeType to prevent XSS
        const safeMimeType = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'].includes(p.mimeType)
          ? p.mimeType : 'image/jpeg';
        img.src = `data:${safeMimeType};base64,${p.base64}`;
        img.alt = p.fileName;
        photoCard.appendChild(img);

        const infoDiv = document.createElement('div');
        infoDiv.className = 'info';
        photoCard.appendChild(infoDiv);

        const filenameDiv = document.createElement('div');
        filenameDiv.className = 'filename';
        filenameDiv.textContent = p.fileName;
        infoDiv.appendChild(filenameDiv);

        if (p.result) {
          const fields = [
            { label: '区分', value: p.result.photoCategory },
            { label: '工種', value: p.result.workType },
            { label: '種別', value: p.result.variety },
            { label: '測点', value: p.result.station }
          ];

          for (const field of fields) {
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'field';
            const span = document.createElement('span');
            span.textContent = field.value || '-';
            fieldDiv.append(`${field.label}: `, span);
            infoDiv.appendChild(fieldDiv);
          }
        } else {
          const fieldPending = document.createElement('div');
          fieldPending.className = 'field';
          fieldPending.style.color = '#999';
          fieldPending.textContent = '未解析';
          infoDiv.appendChild(fieldPending);
        }

        fragment.appendChild(photoCard);
      });

      photosGrid.appendChild(fragment);
    }

    function updateButtons() {
      analyzeBtn.disabled = photos.length === 0 || !apiKeyInput.value;
      const hasResults = photos.some(p => p.result);
      exportSection.style.display = hasResults ? 'block' : 'none';
    }

    clearBtn.addEventListener('click', () => {
      photos = [];
      renderPhotos();
      updateButtons();
      log('クリアしました', 'info');
    });

    // Analysis
    analyzeBtn.addEventListener('click', async () => {
      if (!apiKeyInput.value) {
        log('APIキーを入力してください', 'error');
        return;
      }
      try {
        genAI = new GoogleGenAI({ apiKey: apiKeyInput.value });
        await analyzePhotos();
      } catch (e) {
        log(`エラー: ${e.message}`, 'error');
      }
    });

    async function analyzePhotos() {
      const batchSize = 5;
      const batches = [];
      for (let i = 0; i < photos.length; i += batchSize) {
        batches.push(photos.slice(i, i + batchSize));
      }

      progressSection.style.display = 'block';

      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        const progress = ((i + 1) / batches.length) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `バッチ ${i + 1}/${batches.length} (${batch.length}枚) 処理中...`;

        log(`バッチ ${i + 1} 解析中...`, 'info');

        try {
          const batchResults = await analyzeBatch(batch);
          for (const result of batchResults) {
            const photo = photos.find(p => p.fileName === result.fileName);
            if (photo) photo.result = applyAliases(result); // エイリアス変換適用
          }
          renderPhotos();
          log(`バッチ ${i + 1} 完了`, 'success');
        } catch (e) {
          log(`バッチ ${i + 1} エラー: ${e.message}`, 'error');
        }
      }

      progressText.textContent = `完了: ${photos.filter(p => p.result).length}枚`;
      updateButtons();
      log('全解析完了', 'success');
    }

    async function analyzeBatch(batch) {
      const inputs = batch.map(p => ({
        inlineData: { data: p.base64, mimeType: p.mimeType }
      }));

      const systemPrompt = `あなたは工事写真の解析AIです。各写真を解析して以下の情報を抽出してください：
- photoCategory: 写真区分（施工状況, 品質管理, 出来形管理, 材料検収, 安全管理, 使用材料 など）
- workType: 工種（舗装工, 区画線工 など）
- variety: 種別（アスファルト舗装, 溶融式区画線 など）
- detail: 細別
- station: 測点（NO.10+5.0 など）
- remarks: 備考
- description: 写真の説明
- reasoning: 判定根拠

入力順序と同じ順序でJSON配列を返してください。`;

      const prompt = `${batch.length}枚の写真を解析してください。
各写真について fileName, photoCategory, workType, variety, detail, station, remarks, description, reasoning を含むJSONオブジェクトの配列を返してください。
入力順序と同じ順序で出力してください。

ファイル名: ${batch.map(p => p.fileName).join(', ')}`;

      const result = await genAI.models.generateContent({
        model: 'gemini-2.0-flash',
        contents: [{ role: 'user', parts: [...inputs, { text: prompt }] }],
        config: {
          systemInstruction: systemPrompt,
          responseMimeType: 'application/json',
          temperature: 0.1
        }
      });

      const text = result.text || '[]';
      try {
        const parsed = JSON.parse(text);
        return Array.isArray(parsed) ? parsed : parsed.results || [];
      } catch {
        log('JSONパースエラー', 'error');
        return [];
      }
    }

    // PDF Export
    exportPdfBtn.addEventListener('click', async () => {
      log('PDF生成中...', 'info');
      try {
        const blob = await generatePdf();
        downloadBlob(blob, '工事写真帳.pdf');
        log('PDF出力完了', 'success');
      } catch (e) {
        log(`PDF生成エラー: ${e.message}`, 'error');
      }
    });

    async function generatePdf() {
      const photosPerPage = parseInt(photosPerPageSelect.value);
      const title = titleInput.value || '工事写真帳';
      const pdfDoc = await PDFDocument.create();

      // 日本語フォント埋め込み
      pdfDoc.registerFontkit(fontkit);
      const fontBytes = await fetch(FONT_URL).then(r => r.arrayBuffer());
      const japaneseFont = await pdfDoc.embedFont(fontBytes);

      const usableHeight = A4_HEIGHT - MARGIN * 2 - HEADER_HEIGHT;
      const photoRowHeight = usableHeight / photosPerPage;
      const photoHeight = photoRowHeight - GAP * 2;
      const usableWidth = A4_WIDTH - MARGIN * 2;
      const photoWidth = usableWidth * IMAGE_RATIO;
      const infoWidth = usableWidth * INFO_RATIO;
      const totalPages = Math.ceil(photos.length / photosPerPage);

      for (let pageNum = 0; pageNum < totalPages; pageNum++) {
        const page = pdfDoc.addPage([A4_WIDTH, A4_HEIGHT]);
        const pagePhotos = photos.slice(pageNum * photosPerPage, (pageNum + 1) * photosPerPage);

        // Header
        page.drawText(title, { x: MARGIN, y: A4_HEIGHT - MARGIN - 20, size: UNIFIED_FONT_SIZE, font: japaneseFont, color: rgb(0.2, 0.2, 0.2) });
        page.drawText(`Page ${pageNum + 1} / ${totalPages}`, { x: A4_WIDTH - MARGIN - 80, y: A4_HEIGHT - MARGIN - 20, size: UNIFIED_FONT_SIZE, font: japaneseFont, color: rgb(0.5, 0.5, 0.5) });

        for (let i = 0; i < pagePhotos.length; i++) {
          const photo = pagePhotos[i];
          const rowY = A4_HEIGHT - MARGIN - HEADER_HEIGHT - (i + 1) * photoRowHeight + GAP;

          // Embed image
          if (photo.base64) {
            try {
              const imageBytes = Uint8Array.from(atob(photo.base64), c => c.charCodeAt(0));
              const embeddedImage = photo.mimeType.includes('png')
                ? await pdfDoc.embedPng(imageBytes)
                : await pdfDoc.embedJpg(imageBytes);

              const imgAspect = embeddedImage.width / embeddedImage.height;
              const boxAspect = photoWidth / photoHeight;
              const [drawWidth, drawHeight] = imgAspect > boxAspect
                ? [photoWidth, photoWidth / imgAspect]
                : [photoHeight * imgAspect, photoHeight];

              page.drawImage(embeddedImage, {
                x: MARGIN + (photoWidth - drawWidth) / 2,
                y: rowY + (photoHeight - drawHeight) / 2,
                width: drawWidth,
                height: drawHeight
              });
            } catch (e) {
              console.warn('Image embed error:', e);
            }
          }

          // Photo border
          page.drawRectangle({ x: MARGIN, y: rowY, width: photoWidth, height: photoHeight, borderColor: rgb(0.7, 0.7, 0.7), borderWidth: 0.5 });

          // Info panel
          const infoX = MARGIN + photoWidth + GAP;
          const r = photo.result || {};
          const infoLines = [
            { label: '写真区分', value: r.photoCategory || '-' },
            { label: '工種', value: r.workType || '-' },
            { label: '種別', value: r.variety || '-' },
            { label: '細別', value: r.detail || '-' },
            { label: '測点', value: r.station || '-' },
            { label: '備考', value: r.remarks || '-' }
          ];

          page.drawRectangle({ x: infoX, y: rowY, width: infoWidth, height: photoHeight, borderColor: rgb(0.7, 0.7, 0.7), borderWidth: 0.5 });

          infoLines.forEach((line, idx) => {
            const y = rowY + photoHeight - 15 - idx * 16;
            if (y > rowY + 5) {
              page.drawText(`${line.label}: ${(line.value || '-').substring(0, 25)}`, {
                x: infoX + 5, y, size: UNIFIED_FONT_SIZE, font: japaneseFont, color: rgb(0.2, 0.2, 0.2)
              });
            }
          });

          page.drawText(photo.fileName, { x: infoX + 5, y: rowY + 5, size: UNIFIED_FONT_SIZE, font: japaneseFont, color: rgb(0.5, 0.5, 0.5) });
        }
      }

      pdfDoc.setTitle(title);
      pdfDoc.setCreator('Photo AI Analyzer');
      return new Blob([await pdfDoc.save()], { type: 'application/pdf' });
    }

    // Excel Export
    exportExcelBtn.addEventListener('click', () => {
      log('Excel生成中...', 'info');
      try {
        generateExcel();
        log('Excel出力完了', 'success');
      } catch (e) {
        log(`Excel生成エラー: ${e.message}`, 'error');
      }
    });

    function generateExcel() {
      const data = photos.map((p, i) => ({
        'No': i + 1,
        'ファイル名': p.fileName,
        '写真区分': p.result?.photoCategory || '',
        '工種': p.result?.workType || '',
        '種別': p.result?.variety || '',
        '細別': p.result?.detail || '',
        '測点': p.result?.station || '',
        '備考': p.result?.remarks || '',
        '説明': p.result?.description || ''
      }));

      const ws = XLSX.utils.json_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, '写真台帳');

      // Set column widths
      ws['!cols'] = [
        { wch: 5 },  // No
        { wch: 25 }, // ファイル名
        { wch: 12 }, // 写真区分
        { wch: 15 }, // 工種
        { wch: 15 }, // 種別
        { wch: 15 }, // 細別
        { wch: 12 }, // 測点
        { wch: 20 }, // 備考
        { wch: 30 }  // 説明
      ];

      XLSX.writeFile(wb, '工事写真帳.xlsx');
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    updateButtons();
    log('写真台帳AI 起動', 'info');
  </script>
</body>
</html>
